clc
%% parameters
Ts = 0.1;
PredictionHorizon = 30;
InputHorizon = 5;

MAX_STEETING_RATE = 0.1;
MAX_STEETING_ANGLE = 30*pi/180;
MAX_ACCELERATION = 0.1;

%% ROS Setup
machine_ip = '192.168.68.117';
setenv('ROS_IP',machine_ip);

node = ros2node("/matlab");
pause(2) % wait for ros connection
% ros2 topic list
state_sub = ros2subscriber(node, 'mpc/inputs/state', 'Reliability','besteffort');
track_sub = ros2subscriber(node, 'mpc/inputs/track', 'Reliability','besteffort');
control_pub = ros2publisher(node, 'driving_command');

%% get track & state
track = receive(track_sub, 20);
track_ilen = length(track.path);
decimation = 20;
track_x = zeros([1 floor(track_ilen/decimation)]);
track_y = track_x;
for i = 0:size(track_x, 2)-1
    track_x(i+1) = track.path(i*decimation+1).location.x;
    track_y(i+1) = track.path(i*decimation+1).location.y;
end


%% MPC steup
input_UB = [ones(1, InputHorizon)*MAX_STEETING_RATE; ones(1, InputHorizon)*MAX_ACCELERATION];
input_LB = [-ones(1, InputHorizon)*MAX_STEETING_RATE; -ones(1, InputHorizon)*MAX_ACCELERATION];

end_s = track.path(end).s - (PredictionHorizon+1)*Ts; % no laps just yet
opt = optimoptions('fmincon','Algorithm','active-set', 'Display', 'iter-detailed');%, 'MaxFunctionEvaluations', 3000);

%% run
receive(state_sub, 5); % first state can give bad data
current_state = receive(state_sub, 5);

track_i = 1;
while(track.path(track_i).s < current_state.s)
    track_i = track_i + 1;
end
previous_s = current_state.s - Ts;

tic_ID = tic;

figure(1)
hold on
while(true)
    disp("-----------------")
    % wait until the car has advanced by Ts
    while(previous_s + Ts > current_state.s)
        % while waiting update state and track variables
        current_state = receive(state_sub, 5);
        while(track.path(track_i).s < current_state.s)
            track_i = track_i + 1;
        end

        % periodicly redraw track
        if(toc(tic_ID) > 0.2)
            tic_ID = tic;
            cla
            axis equal
            plot(track_x, track_y)
            plt_bike(current_state, [0 0], track.path(track_i), 'magenta', 1)
            break
        end
    end
    disp(current_state.s - previous_s)
    previous_s = current_state.s;
%     previous_s = previous_s + Ts;

    tic()
    % conversion of data to matching format
    state_vec = [current_state.ey; current_state.etheta; current_state.otheta_dot; max(current_state.vx, 0.01); current_state.vy; current_state.d; double(current_state.t.sec)+double(current_state.t.nanosec)*10e-9];
    track_vec = zeros([PredictionHorizon, 6]);
    track_j = track_i;
    i = 1;
    while(i <= PredictionHorizon)
        while(track.path(track_j).s < current_state.s + Ts*(i-1))
            track_j = track_j + 1;
        end
        track_vec(i, :) = [track.path(track_j).s track.path(track_j).location.x track.path(track_j).location.y track.path(track_j).curvature track.path(track_j).track_angle 0];
        i = i + 1;
    end

    % run mpc
    U = zeros(2, InputHorizon);
    [f, fnonlcons] = getnp(state_vec, @stateChange, track_vec, PredictionHorizon, InputHorizon, Ts);
    [U, C] = fmincon(f, U,[],[],[],[],input_LB,input_UB, fnonlcons, opt);
    toc()
    disp(U)

    X_next = stateChange(state_vec, U(:, 1), track_vec(1, :), Ts);
    
    control_msg = ros2message(control_pub);
    control_msg.steering_angle = single(X_next(end-1)*-pi/MAX_STEETING_ANGLE);
    control_msg.acceleration = single(U(2, 1))
    if 
    send(control_pub, control_msg);

    % draw track after mpc update
    tic_ID = tic;
    cla
    axis equal
    plot(track_x, track_y)
    plt_bike(current_state, [0 0], track.path(track_i), 'magenta', 1)
    
end


